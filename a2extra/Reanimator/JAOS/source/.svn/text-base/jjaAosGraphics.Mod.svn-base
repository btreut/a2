MODULE jjaAosGraphics;	(*automatically generated stub for java/awt/Graphics *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT	WMWindowManager, WMGraphics, WMRectangles,	JC := JVMConsole,	JT := JVMTypes, jjlObject, jjaGraphics, jjlString,	JVM;(*	jjaImage, jjaColor, jjaiImageObserver, jjaPolygon, jjtAttributedCharacterIterator, jjaShape, jjaRectangle, jjaFont, jjaFontMetrics;*)TYPE	Object = jjlObject.Object;	ByteArray = jjlObject.ByteArray;	CharArray = jjlObject.CharArray;	IntArray = jjlObject.IntArray;	String = jjlString.String;	Graphics = jjaGraphics.Class;VAR	debugInfo: JC.LoggingInfo;	(*	Take a look at WMDialogs.Mod and FractalDemo.Mod*)TYPE	JavaFrame* = OBJECT(WMWindowManager.BufferWindow)			PROCEDURE & InitFrame(w, h: LONGINT);			BEGIN				Init(w, h, FALSE); 				manager := WMWindowManager.GetDefaultManager();				manager.Add(100, 100, SELF, {WMWindowManager.FlagFrame});				SetTitle(WMWindowManager.NewString("Jaos"));				canvas.SetColor(0FFFFFFH);			END InitFrame;	END JavaFrame;		AosGraphics* = OBJECT (Graphics)		VAR			frame: JavaFrame;					PROCEDURE init();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;		PROCEDURE clearRect*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* clearRect(IIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END clearRect;		PROCEDURE clipRect*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* clipRect(IIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END clipRect;		PROCEDURE copyArea*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: JT.Int);   (* copyArea(IIIIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END copyArea;		PROCEDURE create3744*(): Graphics;   (* create()Ljava/awt/Graphics; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END create3744;		PROCEDURE create7929*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int): Graphics;   (* create(IIII)Ljava/awt/Graphics; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END create7929;		PROCEDURE dispose*();   (* dispose()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END dispose;		PROCEDURE draw3DRect*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: BOOLEAN);   (* draw3DRect(IIIIZ)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END draw3DRect;		PROCEDURE drawArc*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: JT.Int);   (* drawArc(IIIIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawArc;		(**		  * Draws the specified bytes as text starting at the specified point.		  *		  * @param data The array of bytes to draw.		  * @param offset The offset into the array to start drawing bytes from.		  * @param length The number of bytes to draw.		  * @param x The X coordinate of the point to draw at.		  * @param y The Y coordinate of the point to draw at.		  *)(*	Call method in superclass		PROCEDURE drawBytes*(p0: ByteArray; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int);   (* drawBytes([BIIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawBytes;*)		(**			* Draws the specified bytes as text starting at the specified point.			*			* @param data The array of bytes to draw.			* @param offset The offset into the array to start drawing bytes from.			* @param length The number of bytes to draw.			* @param x The X coordinate of the point to draw at.			* @param y The Y coordinate of the point to draw at.		  *)(*	Call method in superclass		PROCEDURE drawChars7128*(p0: ByteArray; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int);   (* drawChars([BIIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD (has java implementation) *)		END drawChars7128;*)		(**		  * Draws the specified characters starting at the specified point.		  *		  * @param data The array of characters to draw.		  * @param offset The offset into the array to start drawing characters from.		  * @param length The number of characters to draw.		  * @param x The X coordinate of the point to draw at.		  * @param y The Y coordinate of the point to draw at.		  *)(*	Call method in superclass		PROCEDURE drawChars7064*(p0: CharArray; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int);   (* drawChars([CIIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD (has java implementation) *)		END drawChars7064;*)		PROCEDURE drawImage1044*(p0: Graphics; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: JT.Int; p6: JT.Int; p7: JT.Int; p8: JT.Int; p9: Graphics; p10: Graphics): BOOLEAN;   (* drawImage(Ljava/awt/Image;IIIIIIIILjava/awt/Color;Ljava/awt/image/ImageObserver;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawImage1044;		PROCEDURE drawImage6665*(p0: Graphics; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: JT.Int; p6: JT.Int; p7: JT.Int; p8: JT.Int; p9: Graphics): BOOLEAN;   (* drawImage(Ljava/awt/Image;IIIIIIIILjava/awt/image/ImageObserver;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawImage6665;		PROCEDURE drawImage1717*(p0: Graphics; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: Graphics; p6: Graphics): BOOLEAN;   (* drawImage(Ljava/awt/Image;IIIILjava/awt/Color;Ljava/awt/image/ImageObserver;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawImage1717;		PROCEDURE drawImage5076*(p0: Graphics; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: Graphics): BOOLEAN;   (* drawImage(Ljava/awt/Image;IIIILjava/awt/image/ImageObserver;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawImage5076;		PROCEDURE drawImage3663*(p0: Graphics; p1: JT.Int; p2: JT.Int; p3: Graphics; p4: Graphics): BOOLEAN;   (* drawImage(Ljava/awt/Image;IILjava/awt/Color;Ljava/awt/image/ImageObserver;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawImage3663;		PROCEDURE drawImage6150*(p0: Graphics; p1: JT.Int; p2: JT.Int; p3: Graphics): BOOLEAN;   (* drawImage(Ljava/awt/Image;IILjava/awt/image/ImageObserver;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawImage6150;		PROCEDURE drawLine*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* drawLine(IIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawLine;		PROCEDURE drawOval*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* drawOval(IIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawOval;		PROCEDURE drawPolygon2480*(p0: Graphics);   (* drawPolygon(Ljava/awt/Polygon;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawPolygon2480;		PROCEDURE drawPolygon3384*(p0: IntArray; p1: IntArray; p2: JT.Int);   (* drawPolygon([I[II)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawPolygon3384;		PROCEDURE drawPolyline*(p0: IntArray; p1: IntArray; p2: JT.Int);   (* drawPolyline([I[II)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawPolyline;		PROCEDURE drawRect*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* drawRect(IIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawRect;		PROCEDURE drawRoundRect4120*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: JT.Int);   (* drawRoundRect(IIIIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawRoundRect4120;		PROCEDURE drawRoundRect2260*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: BOOLEAN);   (* drawRoundRect(IIIIZ)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawRoundRect2260;		(**		  * Draws the specified string starting at the specified point.		  *		  * @param string The string to draw.		  * @param x The X coordinate of the point to draw at.		  * @param y The Y coordinate of the point to draw at.		  *)		PROCEDURE drawString8528*(p0: String; x: JT.Int; y: JT.Int);   (* drawString(Ljava/lang/String;II)V *)			VAR str: ARRAY 128 OF CHAR; f: WMGraphics.Font; dx, dy: LONGINT;		BEGIN			JT.JavaToOberonString(p0.value.p, 0, LEN(p0.value.p), str);			JC.String(debugInfo, "AosGraphics.drawString8528(");			JC.String(debugInfo, str); JC.String(debugInfo, ", ");			JC.Int(debugInfo, x, 0); JC.String(debugInfo, ", ");			JC.Int(debugInfo, y, 0); JC.String(debugInfo, ")"); JC.Ln(debugInfo);			f := frame.canvas.GetFont();			f.GetStringSize(str, dx, dy);			JC.String(debugInfo, "dx = ");			JC.Int(debugInfo, dx, 0); JC.String(debugInfo, ", dy = ");			JC.Int(debugInfo, dy, 0);  JC.Ln(debugInfo);			frame.canvas.DrawString(x, y, str);						frame.Invalidate(WMRectangles.MakeRect(x, y, x+dx, y+dy));	(*TODO*)		END drawString8528;		PROCEDURE drawString319*(p0: Graphics; p1: JT.Int; p2: JT.Int);   (* drawString(Ljava/text/AttributedCharacterIterator;II)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END drawString319;		PROCEDURE fill3DRect*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: BOOLEAN);   (* fill3DRect(IIIIZ)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END fill3DRect;		PROCEDURE fillArc*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: JT.Int);   (* fillArc(IIIIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END fillArc;		PROCEDURE fillOval*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* fillOval(IIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END fillOval;		PROCEDURE fillPolygon2480*(p0: Graphics);   (* fillPolygon(Ljava/awt/Polygon;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END fillPolygon2480;		PROCEDURE fillPolygon3384*(p0: IntArray; p1: IntArray; p2: JT.Int);   (* fillPolygon([I[II)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END fillPolygon3384;		PROCEDURE fillRect*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* fillRect(IIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END fillRect;		PROCEDURE fillRoundRect*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int; p4: JT.Int; p5: JT.Int);   (* fillRoundRect(IIIIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END fillRoundRect;		PROCEDURE finalize*();   (* finalize()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END finalize;		PROCEDURE getClip*(): Graphics;   (* getClip()Ljava/awt/Shape; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getClip;		PROCEDURE getClipBounds6623*(): Graphics;   (* getClipBounds()Ljava/awt/Rectangle; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getClipBounds6623;		PROCEDURE getClipBounds3529*(p0: Graphics): Graphics;   (* getClipBounds(Ljava/awt/Rectangle;)Ljava/awt/Rectangle; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getClipBounds3529;		PROCEDURE getClipRect*(): Graphics;   (* getClipRect()Ljava/awt/Rectangle; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getClipRect;		PROCEDURE getColor*(): Graphics;   (* getColor()Ljava/awt/Color; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getColor;		PROCEDURE getFont*(): Graphics;   (* getFont()Ljava/awt/Font; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getFont;		PROCEDURE getFontMetrics8069*(): Graphics;   (* getFontMetrics()Ljava/awt/FontMetrics; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getFontMetrics8069;		PROCEDURE getFontMetrics8729*(p0: Graphics): Graphics;   (* getFontMetrics(Ljava/awt/Font;)Ljava/awt/FontMetrics; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getFontMetrics8729;		PROCEDURE hitClip*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int): BOOLEAN;   (* hitClip(IIII)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END hitClip;		PROCEDURE setClip1240*(p0: JT.Int; p1: JT.Int; p2: JT.Int; p3: JT.Int);   (* setClip(IIII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setClip1240;		PROCEDURE setClip578*(p0: Graphics);   (* setClip(Ljava/awt/Shape;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setClip578;		PROCEDURE setColor*(p0: Graphics);   (* setColor(Ljava/awt/Color;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setColor;		PROCEDURE setFont*(p0: Graphics);   (* setFont(Ljava/awt/Font;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setFont;		PROCEDURE setPaintMode*();   (* setPaintMode()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setPaintMode;		PROCEDURE setXORMode*(p0: Graphics);   (* setXORMode(Ljava/awt/Color;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setXORMode;		PROCEDURE toString*(): Object;   (* toString()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toString;		PROCEDURE translate*(p0: JT.Int; p1: JT.Int);   (* translate(II)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END translate;	END AosGraphics;	PROCEDURE Test*(ptr: PTR): PTR;		VAR t: JavaFrame;	BEGIN		NEW(t, 400, 400);		RETURN NIL;	END Test;		PROCEDURE NewFrame*(par: PTR): PTR;		VAR fp: JVM.FrameFactoryParameters; f: JavaFrame; g: AosGraphics;	BEGIN		fp := par(JVM.FrameFactoryParameters);		NEW(f, fp.w, fp.h);		NEW(g);		g.init();		g.frame := f;		RETURN g	END NewFrame;BEGIN	debugInfo.kind := JC.Debug; debugInfo.source := JC.Graphics;END jjaAosGraphics.System.Free jjaAosGraphics ~Aos.Call jjaAosGraphics.Test ~