MODULE jjiFile;	(*automatically generated stub for java/io/File *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT	AosFS,	JC := JVMConsole,	JT := JVMTypes, jjlObject, jjlString;TYPE	Object = jjlObject.Object;	String = jjlString.String;	RefArray = jjlObject.RefArray;	FilenameFilter = PTR(*jjiFilenameFilter.FilenameFilter*);	FileFilter = PTR(*jjiFileFilter.FileFilter*);	URL = PTR(*jjnURL.URL*);CONST	serialVersionUID* = 301077366599181567;VAR	debugInfo, warningInfo, infoInfo, errorInfo, failureInfo: JC.LoggingInfo;TYPE	File* = OBJECT (Object)		VAR			path-: String;		PROCEDURE init2010*(p0: File; p1: String);   (* <init>(Ljava/io/File;Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init2010;		PROCEDURE init1930*(p0: String);   (* <init>(Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init1930;		PROCEDURE init2121*(p0: String; p1: String);   (* <init>(Ljava/lang/String;Ljava/lang/String;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init2121;		PROCEDURE canRead*(): BOOLEAN;   (* canRead()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END canRead;		PROCEDURE canReadInternal(p0: String): BOOLEAN;   (* canReadInternal(Ljava/lang/String;)Z *)		BEGIN	(* put your implementation here *)			Msg("canReadInternal ", p0);			HALT(99)		END canReadInternal;		PROCEDURE canWrite*(): BOOLEAN;   (* canWrite()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END canWrite;		PROCEDURE canWriteInternal(p0: String): BOOLEAN;   (* canWriteInternal(Ljava/lang/String;)Z *)		BEGIN	(* put your implementation here *)			Msg("canWriteInternal ", p0);			HALT(99)		END canWriteInternal;		PROCEDURE checkRead();   (* checkRead()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END checkRead;		PROCEDURE checkWrite();   (* checkWrite()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END checkWrite;		PROCEDURE compareTo8335*(p0: File): JT.Int;   (* compareTo(Ljava/io/File;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareTo8335;		PROCEDURE compareTo6908*(p0: Object): JT.Int;   (* compareTo(Ljava/lang/Object;)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END compareTo6908;		PROCEDURE createNewFile*(): BOOLEAN;   (* createNewFile()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END createNewFile;		PROCEDURE delete*(): BOOLEAN;   (* delete()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END delete;		PROCEDURE deleteInternal(p0: String): BOOLEAN;   (* deleteInternal(Ljava/lang/String;)Z *)		BEGIN	(* put your implementation here *)			Msg("deleteInternal ", p0);			HALT(99)		END deleteInternal;		PROCEDURE deleteOnExit*();   (* deleteOnExit()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END deleteOnExit;		PROCEDURE equals*(p0: Object): BOOLEAN;   (* equals(Ljava/lang/Object;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END equals;		PROCEDURE exists*(): BOOLEAN;   (* exists()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END exists;		PROCEDURE existsInternal(p0: String): BOOLEAN;   (* existsInternal(Ljava/lang/String;)Z *)		VAR str: ARRAY 256 OF CHAR; res: BOOLEAN;		BEGIN			ConvertName(p0, str);			res := AosFS.Old(str) # NIL;			IF res THEN				Msg("existsInternal (TRUE)", p0)			ELSE				JC.String(errorInfo, str); JC.Ln(errorInfo);				Msg("existsInternal (FALSE)", p0)			END;			RETURN res		END existsInternal;		PROCEDURE getAbsoluteFile*(): File;   (* getAbsoluteFile()Ljava/io/File; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getAbsoluteFile;		PROCEDURE getAbsolutePath*(): String;   (* getAbsolutePath()Ljava/lang/String; *)			VAR res: String; name, tmp: ARRAY 256 OF CHAR; i: LONGINT; f: AosFS.File;		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)			JC.String(errorInfo, "getAbsolutePath "); JC.Ln(errorInfo);			res := path;			IF res.value.p[res.offset] # ORD("/") THEN				ConvertName(path, name);				f := AosFS.Old(name);				f.GetName(name);				tmp[0] := "/";				WHILE name[i] # 0X DO  tmp[i+1] := name[i]; INC(i)  END;				tmp[i+1] := 0X;				res := jjlString.MakeLiteral1(tmp)			END;			JC.String(errorInfo, "getAbsolutePath "); JC.String(errorInfo, tmp); JC.Ln(errorInfo);			RETURN res		END getAbsolutePath;		PROCEDURE getCanonicalFile*(): File;   (* getCanonicalFile()Ljava/io/File; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getCanonicalFile;		PROCEDURE getCanonicalPath*(): String;   (* getCanonicalPath()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getCanonicalPath;		PROCEDURE getName*(): String;   (* getName()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getName;		PROCEDURE getParent*(): String;   (* getParent()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getParent;		PROCEDURE getParentFile*(): File;   (* getParentFile()Ljava/io/File; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getParentFile;		PROCEDURE getPath*(): String;   (* getPath()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getPath;		PROCEDURE hashCode*(): JT.Int;   (* hashCode()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END hashCode;		PROCEDURE isAbsolute*(): BOOLEAN;   (* isAbsolute()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END isAbsolute;		PROCEDURE isDirectory*(): BOOLEAN;   (* isDirectory()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END isDirectory;		PROCEDURE isDirectoryInternal(p0: String): BOOLEAN;   (* isDirectoryInternal(Ljava/lang/String;)Z *)		BEGIN	(* put your implementation here *)			Msg("isDirectoryInternal ", p0);			HALT(99)		END isDirectoryInternal;		PROCEDURE isFile*(): BOOLEAN;   (* isFile()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END isFile;		PROCEDURE isFileInternal(p0: String): BOOLEAN;   (* isFileInternal(Ljava/lang/String;)Z *)		BEGIN	(* put your implementation here *)			Msg("isFileInternal ", p0);			HALT(99)		END isFileInternal;		PROCEDURE isHidden*(): BOOLEAN;   (* isHidden()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END isHidden;		PROCEDURE lastModified*(): JT.Long;   (* lastModified()J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END lastModified;		PROCEDURE lastModifiedInternal(p0: String): JT.Long;   (* lastModifiedInternal(Ljava/lang/String;)J *)		BEGIN	(* put your implementation here *)			Msg("lastModifiedInternal ", p0);			HALT(99)		END lastModifiedInternal;		PROCEDURE length*(): JT.Long;   (* length()J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END length;		PROCEDURE lengthInternal(p0: String): JT.Long;   (* lengthInternal(Ljava/lang/String;)J *)			VAR str: ARRAY 256 OF CHAR; res: LONGINT; f: AosFS.File;		BEGIN	(* put your implementation here *)			ConvertName(p0, str);			res := 0;			f := AosFS.Old(str);			IF f # NIL THEN res := f.Length() END;			RETURN res		END lengthInternal;		PROCEDURE list3249*(): RefArray;   (* list()[Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END list3249;		PROCEDURE list5871*(p0: FilenameFilter): RefArray;   (* list(Ljava/io/FilenameFilter;)[Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END list5871;		PROCEDURE listFiles4743*(): RefArray;   (* listFiles()[Ljava/io/File; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END listFiles4743;		PROCEDURE listFiles1440*(p0: FileFilter): RefArray;   (* listFiles(Ljava/io/FileFilter;)[Ljava/io/File; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END listFiles1440;		PROCEDURE listFiles3100*(p0: FilenameFilter): RefArray;   (* listFiles(Ljava/io/FilenameFilter;)[Ljava/io/File; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END listFiles3100;		PROCEDURE listInternal(p0: String): RefArray;   (* listInternal(Ljava/lang/String;)[Ljava/lang/String; *)		BEGIN	(* put your implementation here *)			Msg("listInternal ", p0);			HALT(99)		END listInternal;		PROCEDURE mkdir*(): BOOLEAN;   (* mkdir()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END mkdir;		PROCEDURE mkdirInternal(p0: String): BOOLEAN;   (* mkdirInternal(Ljava/lang/String;)Z *)		BEGIN	(* put your implementation here *)			Msg("mkdirInternal ", p0);			HALT(99)		END mkdirInternal;		PROCEDURE mkdirs*(): BOOLEAN;   (* mkdirs()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END mkdirs;		PROCEDURE readObject(p0: PTR(*jjiObjectInputStream.Class*));   (* readObject(Ljava/io/ObjectInputStream;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END readObject;		PROCEDURE renameTo*(p0: File): BOOLEAN;   (* renameTo(Ljava/io/File;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END renameTo;		PROCEDURE renameToInternal(p0: String; p1: String): BOOLEAN;   (* renameToInternal(Ljava/lang/String;Ljava/lang/String;)Z *)		BEGIN	(* put your implementation here *)			Msg("renameToInternal ", p0);			HALT(99)		END renameToInternal;		PROCEDURE setLastModified*(p0: JT.Long): BOOLEAN;   (* setLastModified(J)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setLastModified;		PROCEDURE setLastModifiedInternal(p0: String; p1: JT.Long): BOOLEAN;   (* setLastModifiedInternal(Ljava/lang/String;J)Z *)		BEGIN	(* put your implementation here *)			Msg("setLastModifiedInternal ", p0);			HALT(99)		END setLastModifiedInternal;		PROCEDURE setReadOnly*(): BOOLEAN;   (* setReadOnly()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setReadOnly;		PROCEDURE setReadOnlyInternal(p0: String): BOOLEAN;   (* setReadOnlyInternal(Ljava/lang/String;)Z *)		BEGIN	(* put your implementation here *)			Msg("setReadOnlyInternal ", p0);			HALT(99)		END setReadOnlyInternal;		PROCEDURE toString*(): Object;   (* toString()Ljava/lang/String; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toString;		PROCEDURE toURL*(): URL;   (* toURL()Ljava/net/URL; *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toURL;		PROCEDURE writeObject(p0: PTR (*jjiObjectOutputStream.Class*));   (* writeObject(Ljava/io/ObjectOutputStream;)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END writeObject;	END File;VAR	separator*: String;	separatorChar*: CHAR16;	pathSeparator*: String;	pathSeparatorChar*: CHAR16;	PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;	PROCEDURE createInternal(p0: String): BOOLEAN;   (* createInternal(Ljava/lang/String;)Z *)	BEGIN	(* put your implementation here *)		Msg("createInternal ", p0);		HALT(99)	END createInternal;	PROCEDURE createTempFile8319*(p0: String; p1: String): File;   (* createTempFile(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END createTempFile8319;	PROCEDURE createTempFile4057*(p0: String; p1: String; p2: File): File;   (* createTempFile(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END createTempFile4057;	PROCEDURE listRoots*(): RefArray;   (* listRoots()[Ljava/io/File; *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END listRoots;		PROCEDURE ConvertName*(s: String; VAR str: ARRAY OF CHAR);		VAR i, off: LONGINT;				PROCEDURE HasPrefix(pre: ARRAY OF CHAR; off: LONGINT): BOOLEAN;			VAR i: LONGINT;		BEGIN			i := 0;			WHILE (pre[i] # 0X) & (str[off+i] = pre[i]) DO  INC(i)  END;			RETURN str[off+i] = pre[i]		END HasPrefix;			BEGIN		jjlString.ToOberon(s, str);		JC.String(warningInfo, "Convert "); JC.String(warningInfo, str); JC.String(warningInfo, " -> ");		off := 0;		IF HasPrefix("file://", off) THEN			INC(off, 7)		END;		IF str[off] = "/" THEN			INC(off)		END;				IF off # 0 THEN			i := off;			WHILE str[i] # 0X DO str[i-off] := str[i]; INC(i) END;			str[i-off] := 0X		END;		JC.String(warningInfo, str); JC.Ln(warningInfo)	END ConvertName;		PROCEDURE Msg(msg: ARRAY OF CHAR; s: String);		VAR str: ARRAY 256 OF CHAR;	BEGIN		JC.String(errorInfo, msg); JC.Str(errorInfo, s.value.p); JC.Ln(errorInfo)	END Msg;BEGIN	debugInfo.kind := JC.Debug; debugInfo.source := JC.Streams;	warningInfo.kind := JC.Warning; debugInfo.source := JC.Streams;	infoInfo.kind := JC.Info; infoInfo.source := JC.Streams;	errorInfo.kind := JC.Error; errorInfo.source := JC.Streams;	failureInfo.kind := JC.Failure; failureInfo.source := JC.Streams;END jjiFile.(*	11.01.04	prk	update to classpath 0.06	30.07.03	prk	Logging functions, add kind and source; filtering support	12.02.03	prk	Logging functions, use same interface as AosOut	16.10.01	prk	classpath update and file redesign*)