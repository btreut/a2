(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjlObject;	(*automatically generated stub for java/lang/Object *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT		SYSTEM, AosModules, AosActive, AosKernel, AosBoot,		JT := JVMTypes, JS:= JVMSystem;VAR	Nwait, NwaitTimed, Nlock0, Nlock1: LONGINT;		TYPE	Timer = OBJECT(AosActive.Timer)		VAR			wakeup: BOOLEAN;			owner: Object;				PROCEDURE Wakeup;		BEGIN			wakeup := TRUE;			IF owner # NIL THEN owner.signal END		END Wakeup;				PROCEDURE Stop;		BEGIN			owner := NIL;			AosActive.CancelTimeout(SELF)		END Stop;				PROCEDURE & Init(owner: Object; delay: LONGINT);		BEGIN			wakeup := FALSE;			SELF.owner := owner;			AosActive.SetTimeout(SELF, Wakeup, delay)		END Init;	END Timer;		TicketList = POINTER TO RECORD		ticket: LONGINT;		next: TicketList	END;				Object* = OBJECT		VAR 			class*: Object;	(*cached value*)			depth: LONGINT;	(*lock count*)			next, current: LONGINT;	(* values for ticket algorithm *)			returned: TicketList;	(* list of ticket returned by threads whose time-out expired *)							PROCEDURE getClass*(): Object;   (** getClass()Ljava/lang/Class; *)	(**return Object to break recursion*)		VAR tt: LONGINT; td: JS.Descriptor; name: ARRAY 32 OF CHAR;		BEGIN			IF ~classLoaded THEN				Initialize("java/lang/Class");				classLoaded := TRUE			END;			IF class = NIL THEN				SYSTEM.GET(SYSTEM.VAL(LONGINT, SELF)-4, tt);				SYSTEM.GET(tt-4, td);				COPY(td.name, name);				HALT(99);			END;			RETURN class;		END getClass;		PROCEDURE hashCode*(): JT.Int;   (* hashCode()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END hashCode;		PROCEDURE equals*(p0: Object): BOOLEAN;   (* equals(Ljava/lang/Object;)Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END equals;		PROCEDURE clone*(): Object;   (* clone()Ljava/lang/Object; *)			VAR obj: Object;  desc: JS.Descriptor;		BEGIN	(* overwrite java implementation *)			desc := JS.GetDescriptor(SYSTEM.VAL( LONGINT, SELF));			JS.NewRec(SYSTEM.VAL(PTR, obj), desc.tag);						SYSTEM.MOVE(SYSTEM.VAL( LONGINT, SELF ), SYSTEM.VAL( LONGINT, obj ), desc.tag.recSize );			RETURN obj		END clone;		PROCEDURE toString*(): Object;   (* toString()Ljava/lang/String; *)	(* should be string *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END toString;				PROCEDURE notify*();   (* notify()V *)		BEGIN (* called when the object is already locked *)			Assert( AosActive.LockedByCurrent( SELF ), "java/lang/IllegalMonitorStateException", "");					IF current # next THEN				INC(current);				WHILE (current # next) & (returned # NIL) & (returned.ticket = current) DO					returned := returned.next;					INC(current)				END			END		END notify;		PROCEDURE notifyAll*();   (* notifyAll()V *)		BEGIN (* called when the object is already locked *)			Assert( AosActive.LockedByCurrent( SELF ), "java/lang/IllegalMonitorStateException" , "");			current := next;			returned := NIL		END notifyAll;		PROCEDURE wait164*();   (* wait()V *)				VAR depth, myTicket : LONGINT;										BEGIN (* called when the object is already locked *)			AosBoot.Inc(Nwait);					Assert(AosActive.LockedByCurrent(SELF), "java/lang/IllegalMonitorStateException", "");									myTicket := next; INC(next);			depth := SELF.depth;	(* save lock depth *)			AWAIT(myTicket-current < 0);			SELF.depth := depth	(* restore lock depth *)		END wait164;		PROCEDURE wait108*(delay: JT.Long);   (* wait(J)V *) 																	 		VAR depth, myTicket : LONGINT; timer : Timer; p, q: TicketList;		BEGIN (* called when the object is already locked *)			IF delay = 0 THEN				wait164			ELSE				AosBoot.Inc(NwaitTimed);				Assert( AosActive.LockedByCurrent( SELF ), "java/lang/IllegalMonitorStateException" , "");				myTicket := next; INC( next ); 				ASSERT(delay = SHORT(delay));	(* timer works with LONGINT only *)				NEW(timer, SELF, SHORT(delay));				depth := SELF.depth; 				AWAIT((timer.wakeup OR (myTicket - current < 0)));				SELF.depth := depth;				timer.Stop;				IF timer.wakeup & (myTicket - current > 0) THEN	(* if timeout, add myTicket to the returned list *)					p := returned;					WHILE (p # NIL) & (myTicket - p.ticket > 0)DO q := p; p := p.next END;(*					IF myTicket > current THEN						WHILE (p # NIL) & (p.ticket < myTicket) & (p.ticket > current) DO q := p; p := p.next END					ELSE						WHILE (p # NIL) & ((p.ticket < myTicket) OR (p.ticket > current)) DO q := p; p := p.next END					END;*)					NEW(p); p.ticket := myTicket;					IF q # NIL THEN						p.next := q.next; q.next := p					ELSE						p.next := returned; returned := p					END				END;				timer := NIL			END		END wait108;		PROCEDURE wait496*(millis: JT.Long; nanos: JT.Int);   (* wait(JI)V *)				BEGIN	(* no nanoseconds possible *)			wait108( millis )		END wait496;		PROCEDURE finalize();   (* finalize()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END finalize;		PROCEDURE init*();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;				PROCEDURE signal; (* force reevaluation of the conditions *)		BEGIN{EXCLUSIVE}		END signal;	END Object;		(* this is the base class of all reference Arrays; that is array of Object's and array's of array's *)	RefArray* = OBJECT (Object)		VAR p*: POINTER TO ARRAY OF Object;		(* all information about the assosiated elements is in the class *)	END RefArray;		CharArray* = OBJECT (Object)		VAR p*: JT.String	END CharArray;		ByteArray* = OBJECT (Object)		VAR p*: POINTER TO ARRAY OF JT.Byte	END ByteArray;	ShortArray* = OBJECT (Object)		VAR p*: POINTER TO ARRAY OF JT.Short	END ShortArray;		IntArray* = OBJECT (Object)		VAR p*: POINTER TO ARRAY OF JT.Int	END IntArray;		FloatArray* = OBJECT (Object)		VAR p*: POINTER TO ARRAY OF JT.Float	END FloatArray;		BoolArray* = OBJECT (Object)		VAR p*: POINTER TO ARRAY OF BOOLEAN	END BoolArray;		DoubleArray* = OBJECT (Object)		VAR p*: POINTER TO ARRAY OF JT.Double	END DoubleArray;		LongArray* = OBJECT (Object)		VAR p*: POINTER TO ARRAY OF JT.Long	END LongArray;	Body* = PROCEDURE (typetag: LONGINT; self: Object );	Condition* = PROCEDURE (slink: LONGINT): BOOLEAN;			VAR	Initialize*: PROCEDURE(class: ARRAY OF CHAR);	CreateActivity*:PROCEDURE( body :Body; priority: LONGINT; flags: SET; obj: Object);	Lock*: PROCEDURE(obj : Object );	Unlock*: PROCEDURE(obj : Object ); 	Passivate*: PROCEDURE(cond: Condition;  slink: LONGINT;  obj: Object;  flags: SET);	AosLock: PROCEDURE( obj : Object; exclusive : BOOLEAN );	AosUnlock: PROCEDURE( obj : Object; dummy : LONGINT );	Assert*: PROCEDURE( condition : BOOLEAN; extype, msg : ARRAY OF CHAR);	class* : Object;		classLoaded: BOOLEAN;PROCEDURE OberonStrToByteArray*( string : ARRAY OF CHAR; bytes : ByteArray );VAR i, len : LONGINT;BEGIN	len := LEN(string);	NEW( bytes.p, len);	FOR i := 0 TO len-1 DO bytes.p[i] := SHORT(ORD(string[i])) ENDEND OberonStrToByteArray;PROCEDURE JLock(obj : Object);BEGIN (* no need to lock *)	IF AosActive.LockedByCurrent(obj) THEN (* assert depth not too big *)		AosBoot.Inc(Nlock1);		INC(obj.depth)	 ELSE	 	AosBoot.Inc(Nlock0);		(* from now locker is owner of object*)		AosLock(obj, TRUE); obj.depth := 1  				ENDEND JLock;PROCEDURE JUnlock( obj : Object );BEGIN	DEC(obj.depth );	IF obj.depth = 0 THEN AosUnlock(obj, 1 ) ENDEND JUnlock;PROCEDURE Init;BEGIN	classLoaded := FALSE;	SYSTEM.PUT( SYSTEM.ADR( CreateActivity ), AosModules.kernelProc[3] );	SYSTEM.PUT( SYSTEM.ADR( Passivate ), AosModules.kernelProc[4] );		SYSTEM.PUT( SYSTEM.ADR( AosLock ), AosModules.kernelProc[6] );	SYSTEM.PUT( SYSTEM.ADR( AosUnlock ), AosModules.kernelProc[7] );		Lock := JLock;	Unlock := JUnlock;END Init;PROCEDURE clinit();   (* <clinit>()V *)BEGIN	(* DON'T IMPLEMENT THIS METHOD *)END clinit;BEGIN			Init;END jjlObject.(*	11.01.02	prk	Aos 21.12.01 port	23.10.01	prk	timed wait	18.09.01	prk	load Field, Method, and Class on demand only	16.08.01	prk	Remove use of Oberon modules, use only Aos ones	11.04.01	prk	update to classpath 0.02*)