(* Jaos, Copyright 2003, Patrik Reali, ETH Zurich *)MODULE jjiFileDescriptor;	(*automatically generated stub for java/io/FileDescriptor *)	(*WARNING: DON'T CHANGE THE PROCEDURE NAMES*)IMPORT	SYSTEM, AosKernel, AosFS,	JC := JVMConsole,	JT := JVMTypes, jjlObject, jjlString;TYPE	ChAr = ARRAY OF CHAR;	Object = jjlObject.Object;VAR	(*		FileTable contains riders to the files currently in use.		0 to 2 are special and not used (stdin, stdout, stderr)		FileOutputStream and FileInputStream access the FileTable		directly.		Descriptors are added with Allocate(..) and removed with Release(..)	*)	FileTable*: ARRAY 256 OF AosFS.Rider;		AmaxFiles, AcurFiles, AtotFiles: LONGINT;		warningInfo, errorInfo: JC.LoggingInfo;CONST	Set* = 0;		(* SET, modified to avoid conflict with keyword *)	CUR* = 1;	End* = 2;		(* End, modified to avoid conflict with keyword *)	READ* = 1;	WRITE* = 2;	APPEND* = 4;	Excl* = 8;		(* EXCL, modified to avoid conflict with keyword *)	SYNC* = 16;	DSYNC* = 32;TYPE	FileDescriptor* = OBJECT (Object)		VAR(*			nativefd-: LONGINT;*)			nativeFd*: HUGEINT;					PROCEDURE init*();   (* <init>()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init;		PROCEDURE init108(p0: JT.Long);   (* <init>(J)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init108;		PROCEDURE init4156(p0: jjlString.String; p1: JT.Int);   (* <init>(Ljava/lang/String;I)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END init4156;		PROCEDURE available(): JT.Int;   (* available()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END available;		PROCEDURE close();   (* close()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END close;		PROCEDURE finalize();   (* finalize()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END finalize;		PROCEDURE finit();   (* finit$()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END finit;		PROCEDURE getFilePointer(): JT.Long;   (* getFilePointer()J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getFilePointer;		PROCEDURE getLength(): JT.Long;   (* getLength()J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getLength;		PROCEDURE getNativeFd(): JT.Long;   (* getNativeFd()J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END getNativeFd;		PROCEDURE nativeAvailable(p0: JT.Long): JT.Int;   (* nativeAvailable(J)I *)			VAR res: LONGINT; resH: HUGEINT;		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			IF p0 = 0 THEN				(*stdin*)				res := JC.input.Available(0)			ELSIF (p0 = 1) OR (p0 = 2) THEN				res := 0			ELSE				resH := nativeGetLength(p0);	(* workaround for Paco Bug #40 *)				res := SHORT(resH - nativeGetFilePointer(p0))			END;			RETURN res		END nativeAvailable;		PROCEDURE nativeClose(p0: JT.Long): JT.Long;   (* nativeClose(J)J *)		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			ASSERT(p0 > 2);			FileTable[p0].file.Update();			Release(SHORT(p0));			RETURN 0		END nativeClose;		(** exported for bootstrap purposes *)		PROCEDURE nativeGetFilePointer*(p0: JT.Long): JT.Long;   (* nativeGetFilePointer(J)J *)			VAR res: HUGEINT; a, b: LONGINT;		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			ASSERT(p0 > 2);			RETURN FileTable[p0].file.Pos(FileTable[p0]);		END nativeGetFilePointer;		PROCEDURE nativeGetLength(p0: JT.Long): JT.Long;   (* nativeGetLength(J)J *)		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			ASSERT(p0 > 2);			RETURN FileTable[p0].file.Length();		END nativeGetLength;		PROCEDURE nativeOpen(p0: jjlString.String; p1: JT.Int): JT.Long;   (* nativeOpen(Ljava/lang/String;I)J *)			VAR name: ARRAY 256 OF CHAR; f: AosFS.File; res: LONGINT;		BEGIN	(* put your implementation here *)			ConvertName(p0, name);			f := AosFS.Old(name);			res := -1;			IF f # NIL THEN res := Allocate(f, 0) END;			RETURN res		END nativeOpen;		PROCEDURE nativeReadBuf0*(p0: JT.Long; VAR p1: ARRAY OF CHAR; p2: JT.Int; p3: JT.Int): JT.Int;   (* nativeReadBuf(J[BII)I *)			VAR read, res: LONGINT;		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			IF p0 = 0 THEN				JC.input.Receive(p1, p2, p3, 0, read, res)			ELSIF (p0 = 1) OR (p0 = 2) THEN				(* stdout *)				read := 0			ELSE				FileTable[p0].file.ReadBytes(FileTable[p0], p1, p2, p3);				read := p3 - FileTable[p0].res			END;			RETURN read		END nativeReadBuf0;		PROCEDURE nativeReadBuf(p0: JT.Long; p1: jjlObject.ByteArray; p2: JT.Int; p3: JT.Int): JT.Int;   (* nativeReadBuf(J[BII)I *)			VAR read, res: LONGINT;		BEGIN	(* put your implementation here *)			RETURN nativeReadBuf0(p0, SYSTEM.VAL(ChAr, p1.p^), p2, p3)(*			ASSERT(p0 = nativeFd);			IF p0 = 0 THEN				JC.input.Receive(SYSTEM.VAL(ChAr, p1.p^), p2, p3, 0, read, res)			ELSIF (p0 = 1) OR (p0 = 2) THEN				(* stdout *)				read := 0			ELSE				FileTable[p0].file.ReadBytes(FileTable[p0], SYSTEM.VAL(ChAr, p1.p^), p2, p3);				read := p3 - FileTable[p0].res			END;			RETURN read*)		END nativeReadBuf;		PROCEDURE nativeReadByte(p0: JT.Long): JT.Int;   (* nativeReadByte(J)I *)			VAR byte, read, res: LONGINT; buf: ARRAY 1 OF CHAR; ch: CHAR;		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			byte := -1;			IF p0 = 0 THEN				JC.input.Receive(buf, 0, 1, 0, read, res);				IF read = 1 THEN byte := ORD(buf[0]) END			ELSIF p0 > 2 THEN				FileTable[p0].file.Read(FileTable[p0], ch);				byte := ORD(ch);				IF FileTable[p0].eof THEN byte := -1 END			END;			RETURN byte		END nativeReadByte;				(** exported for bootstrap purposes *)		PROCEDURE nativeSeek*(p0: JT.Long; p1: JT.Long; p2: JT.Int; p3: BOOLEAN): JT.Long;   (* nativeSeek(JJIZ)J *)			VAR dest, len, res: LONGINT;		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			IF p0 > 2 THEN				len := FileTable[p0].file.Length();				IF p2 = 0 (*SET*) THEN					dest := 0				ELSIF p2 = CUR THEN					dest := FileTable[p0].file.Pos(FileTable[p0])				ELSE (*END*)					dest := len				END;				dest := dest + SHORT(p1);				IF (dest > len) & p3 THEN					HALT(99)				ELSE					FileTable[p0].file.Set(FileTable[p0], dest)				END;				res := FileTable[p0].file.Pos(FileTable[p0]);				IF res = len THEN res := -1 END			ELSE				HALT(99)			END;				RETURN res		END nativeSeek;		PROCEDURE nativeSetLength(p0: JT.Long; p1: JT.Long);   (* nativeSetLength(JJ)V *)		BEGIN	(* put your implementation here *)			HALT(99)		END nativeSetLength;		PROCEDURE nativeSync(p0: JT.Long);   (* nativeSync(J)V *)		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			IF p0 > 2 THEN				FileTable[p0].file.Update()			ELSE				jjlObject.Assert(FALSE, "java/io/IOException", "Cannot sync")			END		END nativeSync;		PROCEDURE nativeValid(p0: JT.Long): BOOLEAN;   (* nativeValid(J)Z *)		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			RETURN				((p0 >= 0) & (p0 <= 2)) OR 				((p0 > 2) & (p0 < LEN(FileTable)) & (FileTable[p0].file # NIL))		END nativeValid;		PROCEDURE nativeWriteBuf(p0: JT.Long; p1: jjlObject.ByteArray; p2: JT.Int; p3: JT.Int): JT.Long;   (* nativeWriteBuf(J[BII)J *)			VAR read, res: LONGINT;		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			IF p0 = 0 THEN				res := -1			ELSIF (p0 = 1) OR (p0 = 2) THEN				(* stdout *)				JC.WriteBytes(SYSTEM.VAL(ChAr, p1.p^), p2, p3);				res := 0			ELSE				FileTable[p0].file.WriteBytes(FileTable[p0], SYSTEM.VAL(ChAr, p1.p^), p2, p3);				res := FileTable[p0].res			END;			RETURN res		END nativeWriteBuf;		PROCEDURE nativeWriteByte(p0: JT.Long; p1: JT.Int): JT.Long;   (* nativeWriteByte(JI)J *)			VAR res: LONGINT; buf: ARRAY 1 OF CHAR;		BEGIN	(* put your implementation here *)			ASSERT(p0 = nativeFd);			res := -1;			IF p0 > 2 THEN				FileTable[p0].file.Write(FileTable[p0], CHR(p1));				res := FileTable[p0].res			ELSIF p0 # 0 THEN				buf[0] := CHR(p1);				JC.WriteBytes(buf, 0, 1);				res := 0			END;			RETURN res		END nativeWriteByte;		PROCEDURE open(p0: jjlString.String; p1: JT.Int);   (* open(Ljava/lang/String;I)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END open;		PROCEDURE read187(): JT.Int;   (* read()I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END read187;		PROCEDURE read1591(p0: jjlObject.ByteArray; p1: JT.Int; p2: JT.Int): JT.Int;   (* read([BII)I *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END read1591;		PROCEDURE seek(p0: JT.Long; p1: JT.Int; p2: BOOLEAN): JT.Long;   (* seek(JIZ)J *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END seek;		PROCEDURE setLength(p0: JT.Long);   (* setLength(J)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setLength;		PROCEDURE setNativeFd(p0: JT.Long);   (* setNativeFd(J)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END setNativeFd;		PROCEDURE sync*();   (* sync()V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END sync;		PROCEDURE valid*(): BOOLEAN;   (* valid()Z *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END valid;		PROCEDURE write96(p0: JT.Int);   (* write(I)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END write96;		PROCEDURE write1576(p0: jjlObject.ByteArray; p1: JT.Int; p2: JT.Int);   (* write([BII)V *)		BEGIN	(* DON'T IMPLEMENT THIS METHOD *)		END write1576;			END FileDescriptor;VAR	in*: FileDescriptor;	out*: FileDescriptor;	err*: FileDescriptor;	PROCEDURE clinit();   (* <clinit>()V *)	BEGIN	(* DON'T IMPLEMENT THIS METHOD *)	END clinit;	PROCEDURE nativeInit();   (* nativeInit()V *)		VAR a: LONGINT;	BEGIN	(* put your implementation here *)		JC.String(warningInfo, "FileDescriptor.nativeInit"); JC.Ln(warningInfo);		in.nativeFd := 0;		out.nativeFd := 1;		err.nativeFd := 2;	END nativeInit;	PROCEDURE Release*(fd: LONGINT);	BEGIN		AosKernel.AtomicAdd(AcurFiles, -1);		IF (fd < 0) OR (fd >= LEN(FileTable)) THEN			JC.String(errorInfo, "Release, invalid fd "); JC.Int(errorInfo, fd, 0); JC.Ln(errorInfo)		END;		jjlObject.Assert((fd >= 0) & (fd < LEN(FileTable)), "java/lang/Exception", "");		FileTable[fd].file := NIL	END Release;		PROCEDURE Allocate*(f: AosFS.File; pos: LONGINT): LONGINT;		VAR i: LONGINT;	BEGIN		BEGIN {EXCLUSIVE}			INC(AtotFiles); INC(AcurFiles);			IF AcurFiles > AmaxFiles THEN AmaxFiles := AcurFiles END;			i := 3;			WHILE (i < LEN(FileTable)) & (FileTable[i].file # NIL) DO  INC(i)  END;			IF i < LEN(FileTable) THEN				f.Set(FileTable[i], pos)			END		END;		IF i = LEN(FileTable) THEN			JC.String(errorInfo, "Allocate, fd not found"); JC.Int(errorInfo, i, 0); JC.Ln(errorInfo)		END;		jjlObject.Assert(i < LEN(FileTable), "java/lang/Exception", "");		RETURN i	END Allocate;	PROCEDURE ConvertName*(s: jjlString.String; VAR str: ARRAY OF CHAR);		VAR i, off: LONGINT;				PROCEDURE HasPrefix(pre: ARRAY OF CHAR; off: LONGINT): BOOLEAN;			VAR i: LONGINT;		BEGIN			i := 0;			WHILE (pre[i] # 0X) & (str[off+i] = pre[i]) DO  INC(i)  END;			RETURN str[off+i] = pre[i]		END HasPrefix;			BEGIN		jjlString.ToOberon(s, str);		JC.String(warningInfo, "Convert "); JC.String(warningInfo, str); JC.String(warningInfo, " -> ");		off := 0;		IF HasPrefix("file://", off) THEN			INC(off, 7)		END;		IF str[off] = "/" THEN			INC(off)		END;				IF off # 0 THEN			i := off;			WHILE str[i] # 0X DO str[i-off] := str[i]; INC(i) END;			str[i-off] := 0X		END;		JC.String(warningInfo, str); JC.Ln(warningInfo)	END ConvertName;	BEGIN		warningInfo.kind := JC.Warning; warningInfo.source := JC.Streams;		errorInfo.kind := JC.Error; errorInfo.source := JC.Streams;END jjiFileDescriptor.(*	11.01.04	prk	update to classpath 0.06	30.07.03	prk	Logging functions, add kind and source; filtering support	12.02.03	prk	Logging functions, use same interface as AosOut	16.10.01	prk	classpath update and file redesign	16.09.01	prk	console redesign; input implemented; JVMByteBuffer removed	10.07.01	prk	switched to AosFS	11.04.01	prk	update to classpath 0.02	28.03.01	prk	ByteBuffer renamed to JVMByteBuffer*)